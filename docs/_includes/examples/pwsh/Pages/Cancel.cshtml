@page
@model Kestrun.Razor.PwshKestrunModel
@{
}

<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Cancel / Progress (SignalR)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.4; }
        .row { display:flex; gap:1rem; flex-wrap:wrap; align-items:center; }
        .card { border: 1px solid #ddd; border-radius: 12px; padding: 1rem; max-width: 900px; }
        .muted { color:#666; }
        .log { white-space: pre-wrap; background:#111; color:#ddd; padding:1rem; border-radius: 12px; min-height: 220px; }
        button { padding: .55rem .9rem; border-radius: 10px; border: 1px solid #ccc; background: #fafafa; cursor:pointer; }
        button:disabled { opacity:.55; cursor:not-allowed; }
        input { padding: .45rem .6rem; border-radius: 10px; border: 1px solid #ccc; width: 8rem; }
        .pill { display:inline-block; padding:.2rem .5rem; border-radius: 999px; border:1px solid #ddd; background:#f6f6f6; }
    </style>

    <!-- SignalR client (browser) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.7/signalr.min.js"></script>

</head>

<body>
    <h1>Cancellation + Live Progress</h1>
    <p class="muted">
        This page starts a background operation, then listens for SignalR events and updates the UI as progress arrives.
        Hub URL: <span class="pill">/hubs/kestrun</span> :contentReference[oaicite:2]{index=2}
    </p>

    <div class="card">
        <div class="row">
            <label>Seconds:
                <input id="seconds" type="number" min="1" max="600" value="30" />
            </label>

            <button id="btnStart">Start</button>
            <button id="btnCancel" disabled>Cancel</button>

            <span class="muted">TaskId: <code id="taskId">(none)</code></span>
            <span class="muted">State: <span id="state" class="pill">idle</span></span>
        </div>

        <p class="muted" style="margin-top:.75rem">
            Expected server pieces:
            <span class="pill">POST /api/operation/start?seconds=...</span> (returns JSON with <code>TaskId</code>)
            and broadcasts <code>OperationProgress</code>/<code>OperationComplete</code> via <code>Send-KrSignalREvent</code>. :contentReference[oaicite:3]{index=3}
            <br />
            Optional cancel route:
            <span class="pill">GET /tasks/cancel?id=...</span> (Tasks tutorial sample uses <code>Stop-KrTask</code>). :contentReference[oaicite:4]{index=4}
        </p>
    </div>

    <h2 style="margin-top:1.5rem">Live log</h2>
    <div id="log" class="log"></div>

    <script>
        (function () {
            const hubUrl = "/hubs/kestrun";                 // tutorial default :contentReference[oaicite:5]{index=5}
            const startUrl = (s) => "/api/operation/start?seconds=" + encodeURIComponent(s); // SignalR tutorial sample route :contentReference[oaicite:6]{index=6}
            const cancelUrl = (id) => "/tasks/cancel?id=" + encodeURIComponent(id);          // Tasks tutorial sample route :contentReference[oaicite:7]{index=7}

            const elSeconds = document.getElementById("seconds");
            const elStart = document.getElementById("btnStart");
            const elCancel = document.getElementById("btnCancel");
            const elTaskId = document.getElementById("taskId");
            const elState = document.getElementById("state");
            const elLog = document.getElementById("log");

            let currentTaskId = null;

            function log(line) {
                const ts = new Date().toISOString();
                elLog.textContent += `[${ts}] ${line}\n`;
                elLog.scrollTop = elLog.scrollHeight;
            }

            function setState(s) {
                elState.textContent = s;
            }

            // Defensive parsing: supports either (eventName, data) or a single object payload.
            function normalizeEvent(args) {
                // args can be: [eventName, data] OR [payloadObject]
                if (!args || args.length === 0) return { name: null, data: null };

                if (args.length >= 2 && typeof args[0] === "string") {
                    return { name: args[0], data: args[1] };
                }

                const payload = args[0];
                if (!payload) return { name: null, data: null };

                const name = payload.EventName || payload.eventName || payload.Name || payload.name || null;
                const data = payload.Data || payload.data || payload.Payload || payload.payload || payload;
                return { name, data };
            }

            const connection = new signalR.HubConnectionBuilder()
                .withUrl(hubUrl)
                .withAutomaticReconnect()
                .build();

            connection.on("ReceiveEvent", function () {
                const ev = normalizeEvent(arguments);
                if (!ev.name) return;

                // Expecting messages like:
                // OperationProgress: { TaskId, Progress, Step, Message, Timestamp } :contentReference[oaicite:8]{index=8}
                // OperationComplete: { TaskId, Progress, Message, Timestamp }      :contentReference[oaicite:9]{index=9}
                const d = ev.data || {};
                const taskId = d.TaskId || d.taskId || null;

                // If we’re running a task, only show messages for *that* task.
                if (currentTaskId && taskId && taskId !== currentTaskId) return;

                if (ev.name === "OperationProgress") {
                    setState("running");
                    log(`progress ${d.Progress ?? "?"}%: ${d.Message ?? "(no message)"}`);
                } else if (ev.name === "OperationComplete") {
                    setState("completed");
                    log(`complete ${d.Progress ?? "?"}%: ${d.Message ?? "(no message)"}`);
                    elStart.disabled = false;
                    elCancel.disabled = true;
                } else {
                    log(`event ${ev.name}: ` + JSON.stringify(d));
                }
            });

            async function ensureConnected() {
                if (connection.state === signalR.HubConnectionState.Connected) return;
                await connection.start();
                log("SignalR connected");
            }

            elStart.addEventListener("click", async () => {
                elLog.textContent = "";
                setState("starting");
                elStart.disabled = true;

                try {
                    await ensureConnected();

                    const seconds = parseInt(elSeconds.value, 10) || 30;

                    // Start background work (server should return JSON { Success, TaskId, Message } :contentReference[oaicite:10]{index=10}
                    const resp = await fetch(startUrl(seconds), { method: "POST" });
                    const json = await resp.json();

                    currentTaskId = json.TaskId || json.taskId || json.id || null;
                    elTaskId.textContent = currentTaskId || "(unknown)";
                    elCancel.disabled = !currentTaskId;

                    setState("running");
                    log(json.Message || "started");
                } catch (e) {
                    setState("error");
                    log("ERROR starting: " + (e && e.message ? e.message : e));
                    elStart.disabled = false;
                    elCancel.disabled = true;
                }
            });

            elCancel.addEventListener("click", async () => {
                if (!currentTaskId) return;

                setState("cancelling");
                elCancel.disabled = true;

                try {
                    // Tasks tutorial sample uses /tasks/cancel?id=... and Stop-KrTask :contentReference[oaicite:11]{index=11}
                    const resp = await fetch(cancelUrl(currentTaskId), { method: "GET" });
                    if (!resp.ok) throw new Error("Cancel failed: HTTP " + resp.status);

                    log("cancel requested");
                    setState("cancel requested");
                    // You’ll typically see a completion/cancelled message via SignalR shortly after.
                } catch (e) {
                    setState("cancel error");
                    log("ERROR cancelling: " + (e && e.message ? e.message : e));
                    elCancel.disabled = false;
                }
            });

            // Auto-connect early (nice UX)
            ensureConnected().catch(err => log("SignalR connect failed: " + err));
        })();
    </script>
</body>
</html>
