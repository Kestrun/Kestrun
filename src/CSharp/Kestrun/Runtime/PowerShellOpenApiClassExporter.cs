using System.Reflection;
using System.Text;

namespace Kestrun.Runtime;

/// <summary>
/// Exports OpenAPI component classes as PowerShell class definitions.
/// </summary>
public static class PowerShellOpenApiClassExporter
{
    /// <summary>
    /// Holds valid class names to be used as type in the OpenAPI function definitions.
    /// </summary>
    public static List<string> ValidClassNames { get; } = [];

    /// <summary>
    /// Exports OpenAPI component classes found in loaded assemblies
    /// as PowerShell class definitions.
    /// </summary>
    /// <param name="userCallbacks">Optional user-defined functions to include in the export.</param>
    /// <returns>The path to the temporary PowerShell script containing the class definitions.</returns>
    public static string ExportOpenApiClasses(Dictionary<string, string>? userCallbacks)
    {
        var assemblies = AppDomain.CurrentDomain.GetAssemblies()
           .Where(a => a.FullName is not null &&
                    a.FullName.Contains("PowerShell Class Assembly"))
           .ToArray();
        return ExportOpenApiClasses(assemblies: assemblies, userCallbacks: userCallbacks);
    }

    /// <summary>
    /// Exports OpenAPI component classes found in the specified assemblies
    /// as PowerShell class definitions
    /// </summary>
    /// <param name="assemblies">The assemblies to scan for OpenAPI component classes.</param>
    ///  <param name="userCallbacks"> Optional user-defined functions to include in the export.</param>
    /// <returns>The path to the temporary PowerShell script containing the class definitions.</returns>
    public static string ExportOpenApiClasses(Assembly[] assemblies, Dictionary<string, string>? userCallbacks)
    {
        // 1. Collect all component classes
        var componentTypes = assemblies
            .SelectMany(a => a.GetTypes())
            .Where(t => t.IsClass && !t.IsAbstract)
            .Where(HasOpenApiComponentAttribute)
            .ToList();

        // Collect any enums required by the component graph.
        // If a class property uses an enum type constraint, that enum must exist in the session
        // before the class definition is parsed.
        var enumTypes = CollectExportableEnums(componentTypes)
            .OrderBy(t => t.Name, StringComparer.Ordinal)
            .ToList();

        // For quick lookup when choosing type names
        var componentSet = new HashSet<Type>(componentTypes);

        // 2. Topologically sort by "uses other component as property type"
        var sorted = TopologicalSortByPropertyDependencies(componentTypes, componentSet);
        var hasCallbacks = userCallbacks is not null && userCallbacks.Count > 0;

        // nothing to export
        if (sorted.Count == 0 && !hasCallbacks)
        {
            return string.Empty;
        }

        // 3. Emit PowerShell classes (and optional callback functions)
        var sb = new StringBuilder();

        if (enumTypes.Count > 0)
        {
            _ = sb.AppendLine("# ================================================");
            _ = sb.AppendLine("#   Kestrun OpenAPI Autogenerated Enum Definitions");
            _ = sb.AppendLine("# ================================================");
            _ = sb.AppendLine();

            foreach (var enumType in enumTypes)
            {
                AppendEnum(enumType, sb);
                _ = sb.AppendLine(); // blank line between enums
            }
        }

        foreach (var type in sorted)
        {
            // Skip types without full name (should not happen)
            if (type.FullName is null)
            {
                continue;
            }
            if (ValidClassNames.Contains(type.FullName))
            {
                // Already registered remove old entry
                _ = ValidClassNames.Remove(type.FullName);
            }
            // Register valid class name
            ValidClassNames.Add(type.FullName);
            // Emit class definition
            AppendClass(type, componentSet, sb);
            _ = sb.AppendLine(); // blank line between classes
        }

        if (hasCallbacks)
        {
            AppendCallback(sb, userCallbacks);
        }
        // 4. Write to temp script file
        return WriteOpenApiTempScript(sb.ToString());
    }

    /// <summary>
    /// Appends user-defined callback functions to the PowerShell script.
    /// </summary>
    /// <param name="sb"> The StringBuilder to append the callback functions to. </param>
    /// <param name="userCallbacks"> The dictionary of user-defined callback functions, where the key is the function name and the value is the function definition. </param>
    private static void AppendCallback(StringBuilder sb, Dictionary<string, string>? userCallbacks)
    {
        _ = sb.AppendLine("# ================================================");
        _ = sb.AppendLine("#   Kestrun User Callback Functions");
        _ = sb.AppendLine("# ================================================");
        _ = sb.AppendLine();

        foreach (var kvp in userCallbacks!.OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase))
        {
            var name = kvp.Key;
            var definition = kvp.Value ?? string.Empty;

            // Emit a standardized callback function wrapper:
            // - keeps parameter type constraints
            // - strips OpenAPI/Parameter attributes
            // - builds $params and calls $Context.Response.AddCallbackParameters(...)
            var functionScript = BuildCallbackFunctionStub(name, definition);
            var normalized = NormalizeBlankLines(functionScript);
            _ = sb.AppendLine(normalized);
            _ = sb.AppendLine();
        }
    }

    /// <summary>
    /// Normalizes blank lines in the provided PowerShell script.
    /// </summary>
    /// <param name="script">The PowerShell script as a string.</param>
    /// <returns>A string with normalized blank lines.</returns>
    private static string NormalizeBlankLines(string script)
    {
        if (string.IsNullOrWhiteSpace(script))
        {
            return string.Empty;
        }

        // Normalize newlines first
        script = script.Replace("\r\n", "\n").Replace("\r", "\n");

        var lines = script.Split('\n');
        var sb = new StringBuilder(script.Length);

        for (var idx = 0; idx < lines.Length; idx++)
        {
            var line = lines[idx].TrimEnd();
            var isBlank = string.IsNullOrWhiteSpace(line);

            // For callback function export we want compact output:
            // drop ALL whitespace-only lines (attribute stripping leaves many single blank lines).
            if (!isBlank)
            {
                _ = sb.AppendLine(line);
            }
        }

        // Trim trailing newlines
        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Builds a PowerShell function stub for a user-defined callback function.
    /// </summary>
    /// <param name="functionName"> The name of the callback function. </param>
    /// <param name="definition"> The PowerShell function definition as a string. </param>
    /// <returns>A string containing the standardized PowerShell function stub.</returns>
    private static string BuildCallbackFunctionStub(string functionName, string definition)
    {
        var (paramBlock, paramNames, bodyParamName) = TryExtractParamInfo(definition);

        // Fall back to a no-param function if we can't parse anything.
        var strippedParamBlock = StripPowerShellAttributeBlocks(paramBlock);
        strippedParamBlock = NormalizeBlankLines(strippedParamBlock);

        // Ensure we always have a param(...) block for consistent output.
        if (string.IsNullOrWhiteSpace(strippedParamBlock))
        {
            strippedParamBlock = "param()";
            paramNames = [];
        }

        var sb = new StringBuilder();
        _ = sb.AppendLine($"function {functionName} {{");

        // Normalize indentation:
        // - "param(" line: 4 spaces
        // - parameter lines: 8 spaces
        // - closing ")": 4 spaces
        foreach (var rawLine in strippedParamBlock.Replace("\r\n", "\n").Replace("\r", "\n").Split('\n'))
        {
            var l = rawLine.Trim();
            if (l.Length == 0)
            {
                continue;
            }

            if (l.Equals(")", StringComparison.Ordinal))
            {
                _ = sb.Append("    ").AppendLine(l);
                continue;
            }

            if (l.StartsWith("param", StringComparison.OrdinalIgnoreCase))
            {
                _ = sb.Append("    ").AppendLine(l);
                continue;
            }

            _ = sb.Append("        ").AppendLine(l);
        }

        _ = sb.AppendLine("    $FunctionName = $MyInvocation.MyCommand.Name");
        _ = sb.AppendLine("    if ($null -eq $Context -or $null -eq $Context.Response) {");
        _ = sb.AppendLine("        if (Test-KrLogger) {");
        _ = sb.AppendLine("            Write-KrLog -Level Warning -Message '{function} must be called inside a route script with Callback enabled.' -Values $FunctionName");
        _ = sb.AppendLine("        } else {");
        _ = sb.AppendLine("            Write-Warning -Message \"$FunctionName must be called inside a route script with Callback enabled.\"");
        _ = sb.AppendLine("        }");
        _ = sb.AppendLine("        return");
        _ = sb.AppendLine("    }");
        _ = sb.AppendLine("    Write-KrLog -Level Information -Message 'Defined callback function {CallbackFunction}' -Values $FunctionName");
        _ = sb.AppendLine("    $params = [System.Collections.Generic.Dictionary[string, object]]::new()");

        foreach (var p in paramNames)
        {
            // Use the exact casing captured from the param block; dictionary keys are case-insensitive in C#.
            _ = sb.AppendLine($"    $params['{p}'] = ${p}");
        }

        _ = sb.AppendLine(bodyParamName is { Length: > 0 }
            ? $"    $bodyParameterName = '{bodyParamName}'"
            : "    $bodyParameterName = $null");

        _ = sb.AppendLine();
        _ = sb.AppendLine("    $Context.Response.AddCallbackParameters(");
        _ = sb.AppendLine("        $MyInvocation.MyCommand.Name,");
        _ = sb.AppendLine("        $bodyParameterName,");
        _ = sb.AppendLine("        $params)");
        _ = sb.AppendLine("}");

        return sb.ToString();
    }

    private static (string ParamBlock, List<string> ParamNames, string? BodyParamName) TryExtractParamInfo(string definition)
    {
        if (string.IsNullOrWhiteSpace(definition))
        {
            return (string.Empty, [], null);
        }

        // Try to isolate the param(...) block from a FunctionInfo.Definition string.
        var paramBlock = ExtractPowerShellParamBlock(definition);
        if (string.IsNullOrWhiteSpace(paramBlock))
        {
            return (string.Empty, [], null);
        }

        // Identify the request body parameter name (prefer OpenApiRequestBody attribute if present)
        // Example: [OpenApiRequestBody(...)] [PaymentStatusChangedEvent]$Body
        var bodyParamName = ExtractBodyParameterName(paramBlock);

        // Strip attribute blocks so we keep only type constraints + $paramName
        var stripped = StripPowerShellAttributeBlocks(paramBlock);
        var paramNames = ExtractParamNamesFromStrippedParamBlock(stripped);

        // If we didn't find OpenApiRequestBody, default to Body if present.
        if (string.IsNullOrWhiteSpace(bodyParamName) && paramNames.Any(p => string.Equals(p, "Body", StringComparison.OrdinalIgnoreCase)))
        {
            bodyParamName = paramNames.First(p => string.Equals(p, "Body", StringComparison.OrdinalIgnoreCase));
        }

        return (paramBlock, paramNames, bodyParamName);
    }

    /// <summary>
    /// States for scanning PowerShell script for quoted segments.
    /// </summary>
    private enum ScanState
    {
        /// <summary>
        /// Normal scanning state (not inside quotes).
        /// </summary>
        Normal,
        /// <summary>
        /// Inside single-quoted string segment.
        /// </summary>
        SingleQuoted,
        /// <summary>
        /// Inside double-quoted string segment.
        /// </summary>
        DoubleQuoted
    }

    /// <summary>
    /// Extracts the parameter block from a PowerShell function definition.
    /// </summary>
    /// <param name="definition"> The PowerShell function definition string. </param>
    /// <returns>The parameter block string including the 'param(...)' syntax; or an empty string if not found.</returns>
    private static string ExtractPowerShellParamBlock(string definition)
    {
        if (string.IsNullOrEmpty(definition))
        {
            return string.Empty;
        }

        var idx = definition.IndexOf("param", StringComparison.OrdinalIgnoreCase);
        if (idx < 0)
        {
            return string.Empty;
        }

        var open = definition.IndexOf('(', idx);
        if (open < 0)
        {
            return string.Empty;
        }

        var depth = 0;
        var state = ScanState.Normal;

        for (var i = open; i < definition.Length; i++)
        {
            if (TryConsumeQuoted(definition, ref i, ref state))
            {
                continue;
            }

            var ch = definition[i];

            if (ch == '(')
            {
                depth++;
                continue;
            }

            if (ch == ')')
            {
                depth--;
                if (depth == 0)
                {
                    return definition.Substring(idx, i - idx + 1);
                }
            }
        }

        return string.Empty;
    }

    /// <summary>
    /// Tries to consume a quoted segment in the PowerShell script.
    /// </summary>
    /// <param name="s"> The input string to scan. </param>
    /// <param name="i"> The current index in the string, passed by reference and updated as the quoted segment is consumed. </param>
    /// <param name="state"> The current scanning state, passed by reference and updated based on quote handling. </param>
    /// <returns>True if a quoted segment was consumed; otherwise, false.</returns>
    private static bool TryConsumeQuoted(string s, ref int i, ref ScanState state)
    {
        var ch = s[i];

        // Enter quote states
        if (state == ScanState.Normal)
        {
            if (ch == '\'') { state = ScanState.SingleQuoted; return true; }
            if (ch == '"') { state = ScanState.DoubleQuoted; return true; }
            return false;
        }

        // Inside single quotes: '' is an escaped single quote
        if (state == ScanState.SingleQuoted)
        {
            if (ch == '\'' && i + 1 < s.Length && s[i + 1] == '\'')
            {
                i++; // consume second '
                return true;
            }

            if (ch == '\'')
            {
                state = ScanState.Normal;
            }

            return true;
        }

        // Inside double quotes: backtick escapes the next char
        if (state == ScanState.DoubleQuoted)
        {
            if (ch == '`' && i + 1 < s.Length)
            {
                i++; // skip escaped char
                return true;
            }

            if (ch == '"')
            {
                state = ScanState.Normal;
            }

            return true;
        }

        return false;
    }

    /// <summary>
    /// Extracts the name of the body parameter from the parameter block, if annotated with [OpenApiRequestBody].
    /// </summary>
    /// <param name="paramBlock"> The parameter block string to search within. </param>
    /// <returns>The name of the body parameter if found; otherwise, null.</returns>
    private static string? ExtractBodyParameterName(string paramBlock)
    {
        // Very targeted heuristic: if [OpenApiRequestBody(...)] is present, pick the following $name.
        // This keeps the exporter decoupled from PowerShell AST dependencies.
        var marker = "OpenApiRequestBody";
        var idx = paramBlock.IndexOf(marker, StringComparison.OrdinalIgnoreCase);
        if (idx < 0)
        {
            return null;
        }

        // Search forward for '$' then capture identifier
        for (var i = idx; i < paramBlock.Length; i++)
        {
            if (paramBlock[i] != '$')
            {
                continue;
            }

            var start = i + 1;
            var end = start;
            while (end < paramBlock.Length)
            {
                var ch = paramBlock[end];
                if (!(char.IsLetterOrDigit(ch) || ch == '_'))
                {
                    break;
                }
                end++;
            }

            if (end > start)
            {
                return paramBlock[start..end];
            }
        }

        return null;
    }

    private static List<string> ExtractParamNamesFromStrippedParamBlock(string strippedParamBlock)
    {
        // Parse variable names only from within param(...)
        // We expect declarations like: [string]$paymentId,
        if (string.IsNullOrWhiteSpace(strippedParamBlock))
        {
            return [];
        }

        var names = new List<string>();
        var s = strippedParamBlock;

        for (var i = 0; i < s.Length; i++)
        {
            if (s[i] != '$')
            {
                continue;
            }

            var start = i + 1;
            var end = start;
            if (start >= s.Length)
            {
                continue;
            }

            if (!(char.IsLetter(s[start]) || s[start] == '_'))
            {
                continue;
            }

            end++;
            while (end < s.Length)
            {
                var ch = s[end];
                if (!(char.IsLetterOrDigit(ch) || ch == '_'))
                {
                    break;
                }
                end++;
            }

            var name = s[start..end];
            if (!names.Contains(name, StringComparer.OrdinalIgnoreCase))
            {
                names.Add(name);
            }

            i = end - 1;
        }

        return names;
    }

    private static string StripPowerShellAttributeBlocks(string script)
    {
        if (string.IsNullOrWhiteSpace(script))
        {
            return string.Empty;
        }

        var sb = new StringBuilder(script.Length);
        var i = 0;
        while (i < script.Length)
        {
            var ch = script[i];
            if (ch != '[')
            {
                _ = sb.Append(ch);
                i++;
                continue;
            }

            // Capture a full bracket block, handling nested [ ... ] (e.g. generic type constraints)
            var start = i;
            var depth = 0;
            var j = i;
            while (j < script.Length)
            {
                var cj = script[j];
                if (cj == '[')
                {
                    depth++;
                }
                else if (cj == ']')
                {
                    depth--;
                    if (depth == 0)
                    {
                        j++; // include closing ']'
                        break;
                    }
                }
                j++;
            }

            // If unbalanced, just emit the rest
            if (depth != 0)
            {
                _ = sb.Append(script.AsSpan(i));
                break;
            }

            var block = script.AsSpan(start, j - start);

            // Attribute blocks always include parentheses in our usage (e.g. [OpenApiPath(...)], [Parameter()]).
            // Keep type constraints like [string], [int], [MyType], [MyType[]], [List[string]].
            if (block.IndexOf('(') >= 0)
            {
                i = j;
                continue;
            }

            _ = sb.Append(block);
            i = j;
        }

        return sb.ToString();
    }

    /// <summary>
    /// Determines if the specified type has an OpenAPI component attribute.
    /// </summary>
    /// <param name="t"></param>
    /// <returns></returns>
    private static bool HasOpenApiComponentAttribute(Type t)
    {
        return t.GetCustomAttributes(inherit: true)
                .Select(a => a.GetType().Name)
                .Any(n =>
                    n.Contains("OpenApiSchemaComponent", StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Appends the PowerShell class definition for the specified type to the StringBuilder.
    /// </summary>
    /// <param name="type"></param>
    /// <param name="componentSet"></param>
    /// <param name="sb"></param>
    private static void AppendClass(Type type, HashSet<Type> componentSet, StringBuilder sb)
    {
        // Detect base type (for parenting). For OpenAPI form models, base type is chosen
        // by KrBindForm.MaxNestingDepth rather than requiring inheritance on the original class.
        var baseClause = string.Empty;
        if (TryGetFormPayloadBasePsName(type, out var formBasePsName))
        {
            baseClause = $" : {formBasePsName}";
        }
        else
        {
            var baseType = type.BaseType;
            if (baseType != null && baseType != typeof(object))
            {
                // Use PS-friendly type name for the base
                var basePsName = ToPowerShellTypeName(baseType, componentSet, collapseToUnderlyingPrimitives: false);
                baseClause = $" : {basePsName}";
            }
        }
        _ = sb.AppendLine("[NoRunspaceAffinity()]");
        _ = sb.AppendLine($"class {type.Name}{baseClause} {{");

        // Only properties *declared* on this type (no inherited ones)
        var props = type.GetProperties(
            BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        foreach (var p in props)
        {
            var psType = ToPowerShellTypeName(p.PropertyType, componentSet, collapseToUnderlyingPrimitives: true);
            _ = sb.AppendLine($"    [{psType}]${p.Name}");
        }

        // Add static XML metadata to guide XmlHelper without requiring PowerShell method invocation
        AppendOpenApiXmlMetadataProperty(type, props, sb);

        _ = sb.AppendLine("}");
    }

    /// <summary>
    /// Appends a static hashtable property containing OpenApiXml metadata for the class and its properties.
    /// </summary>
    /// <remarks>
    /// This is emitted as a static property (not a PowerShell class method) so that C# reflection can read the
    /// metadata without requiring a PowerShell execution context bound to the current thread.
    /// </remarks>
    /// <param name="type">The type to extract OpenApiXml metadata from.</param>
    /// <param name="props">The properties of the type.</param>
    /// <param name="sb">The StringBuilder to append to.</param>
    private static void AppendOpenApiXmlMetadataProperty(Type type, PropertyInfo[] props, StringBuilder sb)
    {
        _ = sb.AppendLine();
        _ = sb.AppendLine("    # Static OpenApiXml metadata for this class");
        _ = sb.AppendLine("    static [hashtable] $XmlMetadata = @{");
        _ = sb.AppendLine("        ClassName = '" + type.Name + "'");

        // Get class-level OpenApiXml attribute
        var classXmlAttr = type.GetCustomAttributes(inherit: false)
            .FirstOrDefault(a => a.GetType().Name == "OpenApiXmlAttribute");

        if (classXmlAttr != null)
        {
            var classXml = BuildXmlMetadataHashtable(classXmlAttr, indent: 12);
            if (!string.IsNullOrWhiteSpace(classXml))
            {
                _ = sb.AppendLine("        ClassXml = @{");
                _ = sb.AppendLine(classXml);
                _ = sb.AppendLine("        }");
            }
        }

        // Get property-level OpenApiXml attributes
        if (props.Length > 0)
        {
            _ = sb.AppendLine("        Properties = @{");
            var hasAnyPropertyXml = false;

            foreach (var prop in props)
            {
                var propXmlAttr = prop.GetCustomAttributes(inherit: false)
                    .FirstOrDefault(a => a.GetType().Name == "OpenApiXmlAttribute");

                if (propXmlAttr != null)
                {
                    var propXml = BuildXmlMetadataHashtable(propXmlAttr, indent: 16);
                    if (!string.IsNullOrWhiteSpace(propXml))
                    {
                        hasAnyPropertyXml = true;
                        _ = sb.AppendLine($"            '{prop.Name}' = @{{");
                        _ = sb.AppendLine(propXml);
                        _ = sb.AppendLine("            }");
                    }
                }
            }

            if (!hasAnyPropertyXml)
            {
                _ = sb.AppendLine("            # No property-level XML metadata");
            }

            _ = sb.AppendLine("        }");
        }

        _ = sb.AppendLine("    }");
    }

    /// <summary>
    /// Builds a PowerShell hashtable representation of OpenApiXml attribute properties.
    /// </summary>
    /// <param name="xmlAttr">The OpenApiXml attribute instance.</param>
    /// <param name="indent">Number of spaces to indent.</param>
    /// <returns>PowerShell hashtable string representation.</returns>
    private static string BuildXmlMetadataHashtable(object xmlAttr, int indent)
    {
        var attrType = xmlAttr.GetType();
        var sb = new StringBuilder();
        var indentStr = new string(' ', indent);

        // Extract properties using reflection
        var nameProp = attrType.GetProperty("Name");
        var namespaceProp = attrType.GetProperty("Namespace");
        var prefixProp = attrType.GetProperty("Prefix");
        var attributeProp = attrType.GetProperty("Attribute");
        var wrappedProp = attrType.GetProperty("Wrapped");

        var name = nameProp?.GetValue(xmlAttr) as string;
        var ns = namespaceProp?.GetValue(xmlAttr) as string;
        var prefix = prefixProp?.GetValue(xmlAttr) as string;
        var isAttribute = attributeProp?.GetValue(xmlAttr) is bool b && b;
        var isWrapped = wrappedProp?.GetValue(xmlAttr) is bool w && w;

        if (!string.IsNullOrWhiteSpace(name))
        {
            _ = sb.AppendLine($"{indentStr}Name = '{EscapePowerShellString(name)}'");
        }

        if (!string.IsNullOrWhiteSpace(ns))
        {
            _ = sb.AppendLine($"{indentStr}Namespace = '{EscapePowerShellString(ns)}'");
        }

        if (!string.IsNullOrWhiteSpace(prefix))
        {
            _ = sb.AppendLine($"{indentStr}Prefix = '{EscapePowerShellString(prefix)}'");
        }

        if (isAttribute)
        {
            _ = sb.AppendLine($"{indentStr}Attribute = $true");
        }

        if (isWrapped)
        {
            _ = sb.AppendLine($"{indentStr}Wrapped = $true");
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Escapes single quotes in a string for PowerShell string literals.
    /// </summary>
    /// <param name="str">The string to escape.</param>
    /// <returns>Escaped string safe for PowerShell single-quoted strings.</returns>
    private static string EscapePowerShellString(string str) => str.Replace("'", "''");

    /// <summary>
    /// Converts a .NET type to a PowerShell type name.
    /// </summary>
    /// <param name="t"></param>
    /// <param name="componentSet"></param>
    /// <param name="collapseToUnderlyingPrimitives">When true, types derived from OpenApiValue&lt;T&gt; are emitted as their underlying primitive (e.g., string/double/bool/long).</param>
    /// <returns></returns>
    private static string ToPowerShellTypeName(Type t, HashSet<Type> componentSet, bool collapseToUnderlyingPrimitives)
    {
        return GetNullableTypeName(t, componentSet, collapseToUnderlyingPrimitives)
            ?? GetOpenApiArrayWrapperTypeName(t, componentSet, collapseToUnderlyingPrimitives)
            ?? GetCollapsedOpenApiPrimitiveTypeName(t, componentSet, collapseToUnderlyingPrimitives)
            ?? GetEnumTypeName(t)
            ?? GetPrimitiveTypeName(t)
            ?? GetArrayTypeName(t, componentSet, collapseToUnderlyingPrimitives)
            ?? FormatComponentOrFallbackName(t, componentSet);
    }

    /// <summary>
    /// Produces a PowerShell nullable type constraint (e.g. <c>Nullable[int]</c>) when the input is a <c>Nullable&lt;T&gt;</c>.
    /// </summary>
    /// <param name="t">The CLR type to inspect.</param>
    /// <param name="componentSet">The set of known OpenAPI component types.</param>
    /// <param name="collapseToUnderlyingPrimitives">Whether OpenAPI primitive wrapper types should be collapsed to primitives.</param>
    /// <returns>The nullable type name, or <c>null</c> when <paramref name="t"/> is not nullable.</returns>
    private static string? GetNullableTypeName(Type t, HashSet<Type> componentSet, bool collapseToUnderlyingPrimitives)
    {
        return Nullable.GetUnderlyingType(t) is Type underlying
            ? $"Nullable[{ToPowerShellTypeName(underlying, componentSet, collapseToUnderlyingPrimitives)}]"
            : null;
    }

    /// <summary>
    /// Produces an element-array type constraint for OpenAPI schema component array wrapper types when appropriate.
    /// </summary>
    /// <param name="t">The CLR type to inspect.</param>
    /// <param name="componentSet">The set of known OpenAPI component types.</param>
    /// <param name="collapseToUnderlyingPrimitives">Whether OpenAPI primitive wrapper types should be collapsed to primitives.</param>
    /// <returns>The array wrapper type name, or <c>null</c> when <paramref name="t"/> is not an OpenAPI array wrapper type.</returns>
    private static string? GetOpenApiArrayWrapperTypeName(Type t, HashSet<Type> componentSet, bool collapseToUnderlyingPrimitives)
        => ResolveElementArrayType(t, componentSet, collapseToUnderlyingPrimitives);

    /// <summary>
    /// Produces the underlying primitive PowerShell type name for OpenAPI primitive wrapper types (e.g. OpenApiString/OpenApiDate).
    /// </summary>
    /// <param name="t">The CLR type to inspect.</param>
    /// <param name="componentSet">The set of known OpenAPI component types.</param>
    /// <param name="collapseToUnderlyingPrimitives">Whether collapsing is enabled.</param>
    /// <returns>The primitive name, or <c>null</c> when <paramref name="t"/> is not an OpenAPI wrapper type (or collapsing is disabled).</returns>
    /// <remarks>
    /// When <paramref name="collapseToUnderlyingPrimitives"/> is <c>true</c>,
    /// types derived from OpenApiValue&lt;T&gt; are emitted as their underlying primitive (e.g., string/double/bool/long).
    /// </remarks>
    private static string? GetCollapsedOpenApiPrimitiveTypeName(Type t, HashSet<Type> componentSet, bool collapseToUnderlyingPrimitives)
        => collapseToUnderlyingPrimitives
           && TryGetOpenApiValueUnderlyingType(t, out var underlying)
           && underlying is not null
            ? ToPowerShellTypeName(underlying, componentSet, collapseToUnderlyingPrimitives)
            : null;

    /// <summary>
    /// Produces the simple name for enum types so PowerShell can bind against the emitted enum definition.
    /// </summary>
    /// <param name="t">The CLR type to inspect.</param>
    /// <returns>The enum name, or <c>null</c> when <paramref name="t"/> is not an enum.</returns>
    private static string? GetEnumTypeName(Type t)
        => t.IsEnum ? t.Name : null;

    /// <summary>
    /// Produces the PowerShell type name for well-known CLR primitives.
    /// </summary>
    /// <param name="t">The CLR type to inspect.</param>
    /// <returns>The primitive name, or <c>null</c> when no primitive mapping exists.</returns>
    private static string? GetPrimitiveTypeName(Type t)
        => ResolvePrimitiveTypeName(t);

    /// <summary>
    /// Produces a PowerShell element-array type constraint (e.g. <c>string[]</c>) for CLR array types.
    /// </summary>
    /// <param name="t">The CLR type to inspect.</param>
    /// <param name="componentSet">The set of known OpenAPI component types.</param>
    /// <param name="collapseToUnderlyingPrimitives">Whether OpenAPI primitive wrapper types should be collapsed to primitives.</param>
    /// <returns>The formatted array name, or <c>null</c> when <paramref name="t"/> is not an array.</returns>
    private static string? GetArrayTypeName(Type t, HashSet<Type> componentSet, bool collapseToUnderlyingPrimitives)
        => t.IsArray && t.GetElementType() is Type elementType
            ? $"{ToPowerShellTypeName(elementType, componentSet, collapseToUnderlyingPrimitives)}[]"
            : null;

    /// <summary>
    /// Formats a component type as its simple name or falls back to full name for other reference types.
    /// </summary>
    /// <param name="t">The CLR type to format.</param>
    /// <param name="componentSet">The set of known OpenAPI component types.</param>
    /// <returns>A PowerShell-friendly type name.</returns>
    private static string FormatComponentOrFallbackName(Type t, HashSet<Type> componentSet)
        => componentSet.Contains(t) || t.FullName is null
            ? t.Name
            : t.FullName;

    /// <summary>
    /// Collects enums referenced by component properties so they can be emitted before class definitions.
    /// </summary>
    /// <param name="componentTypes">Component classes to scan.</param>
    /// <returns>A de-duplicated list of enums to export.</returns>
    private static IEnumerable<Type> CollectExportableEnums(IEnumerable<Type> componentTypes)
    {
        var enums = new HashSet<Type>();

        foreach (var componentType in componentTypes)
        {
            foreach (var p in componentType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                foreach (var enumType in FindEnumsInType(p.PropertyType))
                {
                    _ = enums.Add(enumType);
                }
            }
        }

        return enums;
    }

    /// <summary>
    /// Finds any enum types within a possibly wrapped type (nullable/array/generic).
    /// </summary>
    /// <param name="t">Type to inspect.</param>
    /// <returns>Zero or more enum types found.</returns>
    private static IEnumerable<Type> FindEnumsInType(Type t)
    {
        // Nullable<T>
        if (Nullable.GetUnderlyingType(t) is Type underlying)
        {
            foreach (var e in FindEnumsInType(underlying))
            {
                yield return e;
            }
            yield break;
        }

        // Arrays
        if (t.IsArray)
        {
            foreach (var e in FindEnumsInType(t.GetElementType()!))
            {
                yield return e;
            }
            yield break;
        }

        // Generic arguments
        if (t.IsGenericType)
        {
            foreach (var arg in t.GetGenericArguments())
            {
                foreach (var e in FindEnumsInType(arg))
                {
                    yield return e;
                }
            }
        }

        if (t.IsEnum)
        {
            yield return t;
        }
    }

    /// <summary>
    /// Appends a PowerShell enum definition for the specified .NET enum type.
    /// </summary>
    /// <param name="enumType">Enum type to emit.</param>
    /// <param name="sb">Output StringBuilder.</param>
    private static void AppendEnum(Type enumType, StringBuilder sb)
    {
        if (!enumType.IsEnum)
        {
            return;
        }

        var underlying = Enum.GetUnderlyingType(enumType);
        var psUnderlying = ResolvePrimitiveTypeName(underlying) ?? underlying.FullName ?? "int";

        _ = sb.AppendLine($"enum {enumType.Name} {{");

        foreach (var name in Enum.GetNames(enumType))
        {
            var rawValue = Enum.Parse(enumType, name);
            var numericValue = Convert.ChangeType(rawValue, underlying, provider: System.Globalization.CultureInfo.InvariantCulture);

            // Always emit explicit values to preserve non-sequential enums.
            _ = sb.AppendLine($"    {name} = [{psUnderlying}]{numericValue}");
        }

        _ = sb.AppendLine("}");
    }

    /// <summary>
    /// Resolves the PowerShell type name for OpenAPI array wrapper components.
    /// </summary>
    /// <param name="t">The .NET type to resolve.</param>
    /// <param name="componentSet">The set of known OpenAPI component types.</param>
    /// <param name="collapseToUnderlyingPrimitives">When true, types derived from OpenApiValue&lt;T&gt; are emitted as their underlying primitive (e.g., string/double/bool/long).</param>
    /// <returns>The PowerShell type name for the array element if applicable; otherwise, null.</returns>
    private static string? ResolveElementArrayType(Type t, HashSet<Type> componentSet, bool collapseToUnderlyingPrimitives)
    {
        // OpenAPI schema component array wrappers:
        // Some PowerShell OpenAPI schemas are modeled as a component class with Array=$true,
        // typically inheriting from the element schema type (e.g. EventDates : Date).
        // When referenced as a property type, we want the PowerShell type constraint to be
        // the element array (e.g. [Date[]]) instead of the wrapper class ([EventDates]).
        // IMPORTANT: this must run before OpenApiValue<T> collapsing so wrappers don't lose their array-ness.
        if (collapseToUnderlyingPrimitives && componentSet.Contains(t) && TryGetArrayComponentElementType(t, out var elementType) && elementType is not null)
        {
            // Guard against pathological self-references.
            if (elementType == t)
            {
                return t.Name;
            }

            var elementPsName = ToPowerShellTypeName(elementType, componentSet, collapseToUnderlyingPrimitives);
            return $"{elementPsName}[]";
        }
        return null;
    }

    // Mapping of .NET primitive types to PowerShell type names.
    private static readonly Dictionary<Type, string> PrimitiveTypeAliases =
         new()
         {
             [typeof(bool)] = "bool",
             [typeof(byte)] = "byte",
             [typeof(sbyte)] = "sbyte",
             [typeof(short)] = "short",
             [typeof(ushort)] = "ushort",
             [typeof(int)] = "int",
             [typeof(uint)] = "uint",
             [typeof(long)] = "long",
             [typeof(ulong)] = "ulong",
             [typeof(float)] = "float",
             [typeof(double)] = "double",
             [typeof(decimal)] = "decimal",
             [typeof(char)] = "char",
             [typeof(string)] = "string",
             [typeof(object)] = "object",
             [typeof(DateTime)] = "datetime",
             [typeof(Guid)] = "guid",
             [typeof(byte[])] = "byte[]"
         };

    /// <summary>
    /// Resolves the PowerShell type name for common .NET primitive types.
    /// </summary>
    /// <param name="t">The .NET type to resolve.</param>
    /// <returns>The PowerShell type name if the type is a recognized primitive; otherwise, null.</returns>
    private static string? ResolvePrimitiveTypeName(Type t)
    {
        // unwrap nullable if needed
        t = Nullable.GetUnderlyingType(t) ?? t;

        return PrimitiveTypeAliases.TryGetValue(t, out var alias) ? alias : null;
    }

    private static bool TryGetOpenApiValueUnderlyingType(Type t, out Type? underlyingType)
    {
        underlyingType = null;

        // Walk base types looking for OpenApiScalar<T> (preferred) or OpenApiValue<T> (legacy)
        // by name to avoid hard coupling.
        // OpenApiScalar<T> lives in Kestrun.Annotations and is in the global namespace.
        var current = t;

        while (current is not null && current != typeof(object))
        {
            if (current.IsGenericType)
            {
                var def = current.GetGenericTypeDefinition();
                if (string.Equals(def.Name, "OpenApiScalar`1", StringComparison.Ordinal) ||
                    string.Equals(def.Name, "OpenApiValue`1", StringComparison.Ordinal))
                {
                    underlyingType = current.GetGenericArguments()[0];
                    return true;
                }
            }

            current = current.BaseType;
        }

        return false;
    }

    private static bool TryGetArrayComponentElementType(Type componentType, out Type? elementType)
    {
        elementType = null;

        // We don't take a hard dependency on the annotation type here; this exporter
        // may reflect PowerShell-generated assemblies. We detect the attribute by name
        // and then read common properties via reflection.
        var attr = componentType
            .GetCustomAttributes(inherit: false)
            .FirstOrDefault(a => a.GetType().Name.Contains("OpenApiSchemaComponent", StringComparison.OrdinalIgnoreCase));

        if (attr is null)
        {
            return false;
        }

        var attrType = attr.GetType();
        var arrayProp = attrType.GetProperty("Array");
        if (arrayProp?.GetValue(attr) is not bool isArray || !isArray)
        {
            return false;
        }

        // Prefer explicit ItemsType if provided.
        var itemsTypeProp = attrType.GetProperty("ItemsType");
        if (itemsTypeProp?.GetValue(attr) is Type itemsType)
        {
            elementType = itemsType;
            return true;
        }

        // Common PowerShell pattern: wrapper inherits from element schema.
        var baseType = componentType.BaseType;
        if (baseType is not null && baseType != typeof(object))
        {
            elementType = baseType;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Topologically sort types so that dependencies (property types)
    /// appear before the types that reference them.
    /// </summary>
    /// <param name="types">The list of types to sort.</param>
    /// <param name="componentSet">Set of component types for quick lookup.</param>
    /// <returns>The sorted list of types.</returns>
    private static List<Type> TopologicalSortByPropertyDependencies(
        List<Type> types,
        HashSet<Type> componentSet)
    {
        var result = new List<Type>();
        var visited = new Dictionary<Type, bool>(); // false = temp-mark, true = perm-mark

        foreach (var t in types)
        {
            Visit(t, componentSet, visited, result);
        }

        return result;
    }

    /// <summary>
    /// Visits the type and its dependencies recursively for topological sorting.
    /// </summary>
    /// <param name="t">Type to visit</param>
    /// <param name="componentSet">Set of component types</param>
    /// <param name="visited">Dictionary tracking visited types and their mark status</param>
    /// <param name="result">List to accumulate the sorted types</param>
    private static void Visit(
     Type t,
     HashSet<Type> componentSet,
     Dictionary<Type, bool> visited,
     List<Type> result)
    {
        if (visited.TryGetValue(t, out var perm))
        {
            if (!perm)
            {
                // cycle; ignore for now
                return;
            }
            return;
        }

        // temp-mark
        visited[t] = false;

        var deps = new List<Type>();

        // 1) Dependencies via property types (component properties)
        var propDeps = t.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                        .Select(p => GetComponentDependencyType(p.PropertyType, componentSet))
                        .Where(dep => dep is not null)
                        .Select(dep => dep!)
                        .Distinct();

        deps.AddRange(propDeps);

        // 2) Dependency via base type (parenting)
        var baseType = t.BaseType;
        if (baseType != null && componentSet.Contains(baseType))
        {
            deps.Add(baseType);
        }

        foreach (var dep in deps.Distinct())
        {
            Visit(dep, componentSet, visited, result);
        }

        // perm-mark
        visited[t] = true;
        result.Add(t);
    }

    private static Type? GetComponentDependencyType(Type propertyType, HashSet<Type> componentSet)
    {
        // Unwrap Nullable
        if (Nullable.GetUnderlyingType(propertyType) is Type underlying)
        {
            propertyType = underlying;
        }

        // Unwrap arrays
        if (propertyType.IsArray)
        {
            propertyType = propertyType.GetElementType()!;
        }

        return componentSet.Contains(propertyType) ? propertyType : null;
    }

    /// <summary>
    /// Determines the PowerShell base type for form payload exports based on KrBindForm.MaxNestingDepth.
    /// </summary>
    /// <param name="type">The OpenAPI component type.</param>
    /// <param name="basePsName">The resolved PowerShell base type name.</param>
    /// <returns>True if a form payload base should be applied; otherwise false.</returns>
    private static bool TryGetFormPayloadBasePsName(Type type, out string? basePsName)
    {
        basePsName = null;

        var bindAttr = type.GetCustomAttributes(inherit: false)
            .FirstOrDefault(a => a.GetType().Name.Equals("KrBindFormAttribute", StringComparison.OrdinalIgnoreCase));

        if (bindAttr is null)
        {
            return false;
        }

        var maxDepthProp = bindAttr.GetType().GetProperty("MaxNestingDepth");
        var maxDepth = maxDepthProp?.GetValue(bindAttr) as int?;

        // If MaxNestingDepth > 0, treat as multipart; otherwise form data.
        basePsName = (maxDepth.GetValueOrDefault(0) > 0) ? "KrMultipart" : "KrFormData";
        return true;
    }

    /// <summary>
    /// Writes the OpenAPI class definitions to a temporary PowerShell script file.
    /// </summary>
    /// <param name="openApiClasses">The OpenAPI class definitions as a string.</param>
    /// <returns>The path to the temporary PowerShell script file.</returns>
    public static string WriteOpenApiTempScript(string openApiClasses)
    {
        // Use a stable file name so multiple runspaces share the same script
        var tempPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName() + ".ps1");

        // Ensure directory exists
        _ = Directory.CreateDirectory(Path.GetDirectoryName(tempPath)!);

        // Build content with header
        var sb = new StringBuilder()
        .AppendLine("# ================================================")
        .AppendLine("#   Kestrun OpenAPI Autogenerated Class Definitions")
        .AppendLine("#   DO NOT EDIT - generated at runtime")
        .Append("#   Timestamp: ").Append(DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss")).Append('Z').AppendLine()
        .AppendLine("# ================================================")
        .AppendLine()
        .AppendLine("[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSProvideCommentHelp', '')]")
        .AppendLine("param()")
        .AppendLine(openApiClasses);

        // Save using UTF-8 without BOM
        File.WriteAllText(tempPath, sb.ToString(), new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));

        return tempPath;
    }
}
