name: Publish Release

permissions:
  contents: read   # read release assets

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to promote (e.g., v1.0.0 or v1.0.0-alpha1)"
        required: true
      publish_mode:
        description: "Perform real publish or rehearsal"
        type: choice
        options: [rehearsal, real]
        default: rehearsal
      publish_targets:
        description: "Targets to publish (comma-separated: psgallery, nuget)"
        required: true
        default: "psgallery,nuget"

jobs:
  promote:
    runs-on: ubuntu-latest
    env:
      TAG: ${{ inputs.tag }}
      PUBLISH_MODE: ${{ inputs.publish_mode }}
      TARGETS: ${{ inputs.publish_targets }}
    steps:
      - name: üõéÔ∏è Checkout (for context only)
        uses: actions/checkout@v5

      - name: üì• Download release assets for ${{ inputs.tag }}
        run: |
          mkdir -p ./release-assets
          gh release download "${TAG}" \
            --repo "${GITHUB_REPOSITORY}" \
            --dir ./release-assets \
            --pattern "*"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üßæ Show downloaded files
        run: ls -l ./release-assets

      # ---------- PowerShell Gallery ----------
      - name: ‚öôÔ∏è Prepare module for PSGallery (unzip *.psmodule.zip)
        if: contains(env.TARGETS, 'psgallery')
        shell: pwsh
        run: |
          $zip = Get-ChildItem -Path "./release-assets" -Filter "Kestrun-PSModule-*.zip" | Select-Object -First 1
          if (-not $zip) { throw "No Kestrun-PSModule-*.zip found in release assets." }
          New-Item -ItemType Directory -Force -Path ./stage/module | Out-Null
          Expand-Archive -Path $zip.FullName -DestinationPath ./stage/module -Force
          # If the zip contains the 'Kestrun' folder already, great; if not, publish path still points to that root.
          Get-ChildItem -Recurse ./stage/module | Select-Object -First 10 | Format-Table -Auto

      - name: üöÄ Publish to PowerShell Gallery (PSResourceGet)
        if: contains(env.TARGETS, 'psgallery')
        shell: pwsh
        env:
          PSGALLERY_API_KEY: ${{ secrets.PSGALLERY_API_KEY }}
        run: |
          Import-Module Microsoft.PowerShell.PSResourceGet -Force
          if (-not (Get-PSResourceRepository -Name PSGallery -ErrorAction SilentlyContinue)) {
            Register-PSResourceRepository -PSGallery
          }

          if (-not $env:PSGALLERY_API_KEY) { throw "Missing PSGALLERY_API_KEY" }
          $path = Resolve-Path "./stage/module"
          if ($env:PUBLISH_MODE -eq 'real') {
            Publish-PSResource -Path $path -Repository PSGallery -ApiKey $env:PSGALLERY_API_KEY
          } else {
            # Rehearsal: same command with -WhatIf (API key not needed)
            Publish-PSResource -Path $path -Repository PSGallery -ApiKey $env:PSGALLERY_API_KEY -WhatIf
          }

      # ---------- NuGet.org ----------
      - name: üß™ NuGet rehearsal (list packages)
        if: contains(env.TARGETS, 'nuget') && env.PUBLISH_MODE != 'real'
        run: |
          echo "Rehearsal mode ‚Äî would push these packages:"
          ls -1 ./release-assets/*.nupkg || true
          ls -1 ./release-assets/*.snupkg || true

      - name: üöÄ Push to nuget.org
        if: contains(env.TARGETS, 'nuget') && env.PUBLISH_MODE == 'real'
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          test -n "$NUGET_API_KEY" || (echo "Missing NUGET_API_KEY" && exit 1)
          # nupkg first, then symbols; skip duplicates so re-runs are safe
          find ./release-assets -maxdepth 1 -name "*.nupkg"  -print -exec dotnet nuget push {} --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate \;
          find ./release-assets -maxdepth 1 -name "*.snupkg" -print -exec dotnet nuget push {} --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate \;
