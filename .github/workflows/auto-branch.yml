name: Auto-create & link issue branch

on:
  issues:
    types: [assigned, labeled, edited]

permissions:
  contents: write
  issues: write

jobs:
  create-and-link:
    runs-on: ubuntu-latest
    steps:
      - name: Create & link branch to the issue
        uses: actions/github-script@v7
        with:
          script: |
            const allowed = ['feat','fix','refactor','docs','test','chore','techdebt'];

            const issue    = context.payload.issue;
            const {owner, repo} = context.repo;
            const number   = issue.number;
            const titleRaw = issue.title || '';
            const labels   = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name)).filter(Boolean);

            const labelToType = (name) => {
              const n = name.toLowerCase();
              if (allowed.includes(n)) return n;
              if (['feature','enhancement'].includes(n)) return 'feat';
              if (['bug','bugfix','hotfix'].includes(n)) return 'fix';
              if (['documentation','docs-update'].includes(n)) return 'docs';
              if (['tests','testing'].includes(n)) return 'test';
              if (['ci','build','infra','infrastructure','tooling'].includes(n)) return 'chore';
              if (['tech-debt','tech_debt','debt'].includes(n)) return 'techdebt';
              if (['refactoring','cleanup'].includes(n)) return 'refactor';
              return null;
            };

            let type = null;
            for (const lbl of labels) { const t = labelToType(lbl); if (t) { type = t; break; } }
            if (!type) {
              const m = titleRaw.toLowerCase().match(/^\s*(?:\[(\w+)\]|(\w+)\s*[:|-])/);
              const candidate = m ? (m[1] || m[2]) : null;
              if (candidate && allowed.includes(candidate)) type = candidate;
            }
            if (!type) {
              core.info('No recognizable type found; skipping.');
              return;
            }

            const cleanTitle = titleRaw
              .replace(/^\s*\[(?:feat|fix|refactor|docs|test|chore|techdebt)\]\s*/i, '')
              .replace(/^\s*(?:feat|fix|refactor|docs|test|chore|techdebt)\s*[:|-]\s*/i, '');
            const slug = cleanTitle.toLowerCase()
              .normalize('NFKD').replace(/[\u0300-\u036f]/g, '')
              .replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')
              .slice(0, 60) || `issue-${number}`;

            const branchName = `${type}/${number}-${slug}`;

            // Get IDs & base OID for GraphQL createLinkedBranch
            const q = await github.graphql(`
              query($owner:String!, $repo:String!, $num:Int!) {
                repository(owner:$owner, name:$repo) {
                  id
                  defaultBranchRef { target { ... on Commit { oid } } }
                  issue(number:$num) { id }
                }
              }
            `, { owner, repo, num: number });

            const repositoryId = q.repository.id;
            const issueId      = q.repository.issue.id;
            const baseOid      = q.repository.defaultBranchRef.target.oid;

            // Idempotency: if ref already exists, we still link it
            let refExists = false;
            try {
              await github.rest.git.getRef({ owner, repo, ref: `heads/${branchName}` });
              refExists = true;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            if (!refExists) {
              // Create the branch & link it to the issue in one go
              const mutation = `
                mutation($input: CreateLinkedBranchInput!) {
                  createLinkedBranch(input: $input) {
                    linkedBranch { id ref { name } }
                  }
                }
              `;
              await github.graphql(mutation, {
                input: {
                  issueId,
                  repositoryId,
                  name: branchName,          // branch name (no "refs/heads/")
                  oid: baseOid               // base commit SHA (OID) to branch from
                }
              });
            } else {
              // If branch already exists, just link it via the same mutation
              const mutation = `
                mutation($input: CreateLinkedBranchInput!) {
                  createLinkedBranch(input: $input) {
                    linkedBranch { id ref { name } }
                  }
                }
              `;
              await github.graphql(mutation, {
                input: {
                  issueId,
                  repositoryId,
                  name: branchName
                  // When name exists, GitHub links the existing branch to the issue
                }
              });
            }

            // Nice comment + issue body marker
            const url = `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(branchName)}`;
            await github.rest.issues.createComment({
              owner, repo, issue_number: number,
              body: `✨ Branch created & linked: **\`${branchName}\`** → ${url}`
            });

            const marker = `**Development Branch:** [\`${branchName}\`](${url})`;
            if (!((issue.body||'').includes(branchName))) {
              await github.rest.issues.update({ owner, repo, issue_number: number, body: `${marker}\n\n${issue.body||''}` });
            }

