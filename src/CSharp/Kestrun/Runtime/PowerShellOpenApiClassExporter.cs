using System.Reflection;
using System.Security.Cryptography;
using System.Runtime.Loader;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Kestrun.Runtime;

/// <summary>
/// Exports OpenAPI component classes into a compiled assembly so types have stable identity across runspaces.
/// </summary>
public static class PowerShellOpenApiClassExporter
{
    /// <summary>
    /// Holds valid class names to be used as type in the OpenAPI function definitions.
    /// </summary>
    public static List<string> ValidClassNames { get; } = [];

    /// <summary>
    /// Exports OpenAPI component classes found in loaded assemblies
    /// into a compiled assembly.
    /// </summary>
    /// <returns>The path to the compiled assembly containing the class definitions.</returns>
    public static string ExportOpenApiClasses()
    {
        // Scan all loaded assemblies; callers may define component classes in scripts, modules, or compiled DLLs.
        // We de-dupe types later to avoid collisions.
        var assemblies = AppDomain.CurrentDomain.GetAssemblies().ToArray();
        return ExportOpenApiClasses(assemblies);
    }

    /// <summary>
    /// Exports OpenAPI component classes found in the specified assemblies
    /// into a compiled assembly.
    /// </summary>
    /// <param name="assemblies">The assemblies to scan for OpenAPI component classes.</param>
    /// <returns>The path to the compiled assembly containing the class definitions.</returns>
    public static string ExportOpenApiClasses(Assembly[] assemblies)
    {
        // 1. Collect all component classes
        var componentTypes = assemblies
            .SelectMany(TryGetTypes)
            .Where(t => t.IsClass && !t.IsAbstract)
            .Where(HasOpenApiComponentAttribute)
            .GroupBy(t => t.FullName ?? t.Name, StringComparer.Ordinal)
            .Select(g => g.First())
            .ToList();

        // For quick lookup when choosing type names
        var componentSet = new HashSet<Type>(componentTypes);

        // 2. Topologically sort by "uses other component as property type"
        var sorted = TopologicalSortByPropertyDependencies(componentTypes, componentSet);
        // nothing to export
        if (sorted.Count == 0)
        {
            return string.Empty;
        }
        // 3. Emit C# classes
        var source = GenerateCSharpSource(sorted, componentSet);

        // 4. Compile into a stable, cached DLL per runtime TFM
        return CompileToCachedAssembly(source);
    }

    private static IEnumerable<Type> TryGetTypes(Assembly assembly)
    {
        try
        {
            return assembly.GetTypes();
        }
        catch (ReflectionTypeLoadException ex)
        {
            return ex.Types.Where(t => t is not null)!;
        }
        catch
        {
            return [];
        }
    }

    private static string GenerateCSharpSource(IReadOnlyList<Type> sortedTypes, HashSet<Type> componentSet)
    {
        var sb = new StringBuilder();

        // NOTE: Hash excludes this header to keep the cache stable.
        _ = sb.AppendLine("// ================================================");
        _ = sb.AppendLine("//   Kestrun OpenAPI Autogenerated Class Definitions");
        _ = sb.AppendLine("//   DO NOT EDIT - generated at runtime");
        _ = sb.AppendLine("// ================================================");
        _ = sb.AppendLine();

        foreach (var type in sortedTypes)
        {
            // Skip types without full name (should not happen)
            if (type.FullName is null)
            {
                continue;
            }

            if (ValidClassNames.Contains(type.FullName))
            {
                // Already registered remove old entry
                _ = ValidClassNames.Remove(type.FullName);
            }

            // Register valid class name
            ValidClassNames.Add(type.FullName);

            AppendCSharpClass(type, componentSet, sb);
            _ = sb.AppendLine();
        }

        return sb.ToString();
    }

    /// <summary>
    /// Determines if the specified type has an OpenAPI component attribute.
    /// </summary>
    /// <param name="t"></param>
    /// <returns></returns>
    private static bool HasOpenApiComponentAttribute(Type t)
    {
        return t.GetCustomAttributes(inherit: true)
                .Select(a => a.GetType().Name)
                .Any(n =>
                    n.Contains("OpenApiSchemaComponent", StringComparison.OrdinalIgnoreCase) ||
                    n.Contains("OpenApiRequestBodyComponent", StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Appends the C# class definition for the specified type to the StringBuilder.
    /// </summary>
    /// <param name="type"></param>
    /// <param name="componentSet"></param>
    /// <param name="sb"></param>
    private static void AppendCSharpClass(Type type, HashSet<Type> componentSet, StringBuilder sb)
    {
        // Detect base type (for parenting)
        var baseType = type.BaseType;
        var baseClause = string.Empty;

        if (baseType != null && baseType != typeof(object))
        {
            // Use C#-friendly type name for the base
            var baseCsName = ToCSharpTypeName(baseType, componentSet);
            baseClause = $" : {baseCsName}";
        }

        // Global namespace on purpose: PowerShell class FullName is typically unqualified.
        _ = sb.AppendLine($"public class {type.Name}{baseClause}");
        _ = sb.AppendLine("{");

        // Only properties *declared* on this type (no inherited ones)
        var props = type.GetProperties(
            BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        foreach (var p in props)
        {
            var csType = ToCSharpTypeName(p.PropertyType, componentSet);
            _ = sb.AppendLine($"    public {csType} {p.Name} {{ get; set; }}");
        }

        _ = sb.AppendLine("}");
    }

    /// <summary>
    /// Converts a .NET type to a C# type name suitable for code generation.
    /// </summary>
    /// <param name="t"></param>
    /// <param name="componentSet"></param>
    /// <returns></returns>
    private static string ToCSharpTypeName(Type t, HashSet<Type> componentSet)
    {
        // Nullable<T>
        if (Nullable.GetUnderlyingType(t) is Type underlying)
        {
            // For reference types, nullable annotations are optional; for value types use '?'.
            return underlying.IsValueType
                ? $"{ToCSharpTypeName(underlying, componentSet)}?"
                : ToCSharpTypeName(underlying, componentSet);
        }

        // Primitive mappings
        if (t == typeof(long))
        {
            return "long";
        }

        if (t == typeof(int))
        {
            return "int";
        }

        if (t == typeof(bool))
        {
            return "bool";
        }

        if (t == typeof(string))
        {
            return "string";
        }

        if (t == typeof(double))
        {
            return "double";
        }

        if (t == typeof(float))
        {
            return "float";
        }

        if (t == typeof(decimal))
        {
            return "decimal";
        }

        if (t == typeof(object))
        {
            return "object";
        }

        if (t == typeof(DateTime))
        {
            return "System.DateTime";
        }

        if (t == typeof(DateTimeOffset))
        {
            return "System.DateTimeOffset";
        }

        if (t == typeof(Guid))
        {
            return "System.Guid";
        }

        // Arrays
        if (t.IsArray)
        {
            var element = ToCSharpTypeName(t.GetElementType()!, componentSet);
            return $"{element}[]";
        }

        // If the property type is itself one of the OpenAPI component classes,
        // use its *simple* name (Pet, User, Tag, Category, etc.)
        if (componentSet.Contains(t))
        {
            return t.Name;
        }

        if (t.IsGenericType)
        {
            return ToCSharpGenericTypeName(t, componentSet);
        }

        // Fallback for other reference types
        return (t.FullName ?? t.Name).Replace('+', '.');
    }

    private static string ToCSharpGenericTypeName(Type t, HashSet<Type> componentSet)
    {
        // Generic type definition name (strip arity: `1, `2, ...)
        var def = t.GetGenericTypeDefinition();
        var rawName = (def.FullName ?? def.Name).Replace('+', '.');
        var tick = rawName.IndexOf('`');
        if (tick >= 0)
        {
            rawName = rawName[..tick];
        }

        var args = t.GetGenericArguments()
            .Select(a => ToCSharpTypeName(a, componentSet));

        return $"{rawName}<{string.Join(", ", args)}>";
    }

    /// <summary>
    /// Topologically sort types so that dependencies (property types)
    /// appear before the types that reference them.
    /// </summary>
    /// <param name="types">The list of types to sort.</param>
    /// <param name="componentSet">Set of component types for quick lookup.</param>
    /// <returns>The sorted list of types.</returns>
    private static List<Type> TopologicalSortByPropertyDependencies(
        List<Type> types,
        HashSet<Type> componentSet)
    {
        var result = new List<Type>();
        var visited = new Dictionary<Type, bool>(); // false = temp-mark, true = perm-mark

        foreach (var t in types)
        {
            Visit(t, componentSet, visited, result);
        }

        return result;
    }

    /// <summary>
    /// Visits the type and its dependencies recursively for topological sorting.
    /// </summary>
    /// <param name="t">Type to visit</param>
    /// <param name="componentSet">Set of component types</param>
    /// <param name="visited">Dictionary tracking visited types and their mark status</param>
    /// <param name="result">List to accumulate the sorted types</param>
    private static void Visit(
     Type t,
     HashSet<Type> componentSet,
     Dictionary<Type, bool> visited,
     List<Type> result)
    {
        if (visited.TryGetValue(t, out var perm))
        {
            if (!perm)
            {
                // cycle; ignore for now
                return;
            }
            return;
        }

        // temp-mark
        visited[t] = false;

        var deps = new List<Type>();

        // 1) Dependencies via property types (component properties)
        var propDeps = t.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                        .Select(p => GetComponentDependencyType(p.PropertyType, componentSet))
                        .Where(dep => dep is not null)
                        .Select(dep => dep!)
                        .Distinct();

        deps.AddRange(propDeps);

        // 2) Dependency via base type (parenting)
        var baseType = t.BaseType;
        if (baseType != null && componentSet.Contains(baseType))
        {
            deps.Add(baseType);
        }

        foreach (var dep in deps.Distinct())
        {
            Visit(dep, componentSet, visited, result);
        }

        // perm-mark
        visited[t] = true;
        result.Add(t);
    }

    private static Type? GetComponentDependencyType(Type propertyType, HashSet<Type> componentSet)
    {
        // Unwrap Nullable
        if (Nullable.GetUnderlyingType(propertyType) is Type underlying)
        {
            propertyType = underlying;
        }

        // Unwrap arrays
        if (propertyType.IsArray)
        {
            propertyType = propertyType.GetElementType()!;
        }

        return componentSet.Contains(propertyType) ? propertyType : null;
    }

    private static string CompileToCachedAssembly(string source)
    {
        var hashInput = StripLeadingCommentHeader(source);
        var hash = ComputeSha256Hex(hashInput);
        var tfm = GetRuntimeTfmMoniker();

        var outputDir = Path.Combine(Path.GetTempPath(), "Kestrun", "OpenApiClasses", tfm);
        var outputPath = Path.Combine(outputDir, hash + ".dll");

        // Concurrency: the same hash may be requested from multiple threads/processes.
        // Use a named mutex to ensure only one writer compiles a given outputPath.
        var mutexName = $"Global\\Kestrun.OpenApiClasses.{tfm}.{hash}";
        using var mutex = new Mutex(initiallyOwned: false, name: mutexName);
        var mutexHeld = false;

        try
        {
            mutexHeld = mutex.WaitOne(TimeSpan.FromMinutes(2));

            // Re-check inside the lock.
            if (!File.Exists(outputPath))
            {
                _ = Directory.CreateDirectory(outputDir);

                var tmpPath = outputPath + "." + Environment.ProcessId + ".tmp";
                try
                {
                    CompileCSharpToDll(source, tmpPath, assemblyName: $"Kestrun.OpenApiClasses.{hash}");

                    // Atomic publish.
                    File.Move(tmpPath, outputPath);
                }
                catch (IOException)
                {
                    // Another process likely published first.
                    try
                    {
                        if (File.Exists(tmpPath))
                        {
                            File.Delete(tmpPath);
                        }
                    }
                    catch
                    {
                        /* ignore */
                    }
                }
            }
        }
        finally
        {
            if (mutexHeld)
            {
                try { mutex.ReleaseMutex(); } catch { /* ignore */ }
            }
        }

        // Ensure the assembly is loaded into the process so all runspaces can resolve the types.
        LoadIntoDefaultAssemblyLoadContextIfNeeded(outputPath);

        return outputPath;
    }

    private static void LoadIntoDefaultAssemblyLoadContextIfNeeded(string assemblyPath)
    {
        try
        {
            var alreadyLoaded = AppDomain.CurrentDomain.GetAssemblies()
                .Any(a => !a.IsDynamic &&
                         !string.IsNullOrWhiteSpace(a.Location) &&
                         string.Equals(a.Location, assemblyPath, StringComparison.OrdinalIgnoreCase));

            if (alreadyLoaded)
            {
                return;
            }

            // Load into Default ALC to keep a single type identity across the process.
            _ = AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath);
        }
        catch
        {
            // Best-effort: runspaces may still load via InitialSessionState.Assemblies.
        }
    }

    private static string StripLeadingCommentHeader(string source)
    {
        // Only strip a contiguous comment header at the very top.
        // We intentionally do NOT attempt to remove comments elsewhere.
        using var reader = new StringReader(source);
        var sb = new StringBuilder();
        var skipping = true;
        string? line;

        while ((line = reader.ReadLine()) is not null)
        {
            if (skipping)
            {
                if (line.TrimStart().StartsWith("//", StringComparison.Ordinal) || string.IsNullOrWhiteSpace(line))
                {
                    continue;
                }

                skipping = false;
            }

            _ = sb.AppendLine(line);
        }

        return sb.ToString();
    }

    private static string ComputeSha256Hex(string content)
    {
        var bytes = Encoding.UTF8.GetBytes(content);
        var hashBytes = SHA256.HashData(bytes);
        return Convert.ToHexString(hashBytes).ToLowerInvariant();
    }

    private static string GetRuntimeTfmMoniker()
    {
        // Use the actual runtime version so we always compile against the current process TPA.
        // Example: 8.0.x -> net8.0, 10.0.x -> net10.0
        var v = Environment.Version;
        return $"net{v.Major}.0";
    }

    private static void CompileCSharpToDll(string source, string outputPath, string assemblyName)
    {
        var parseOptions = new CSharpParseOptions(LanguageVersion.Latest);
        var syntaxTree = CSharpSyntaxTree.ParseText(source, parseOptions);

        var references = GetTrustedPlatformAssemblyReferences();
        var compilation = CSharpCompilation.Create(
            assemblyName,
            [syntaxTree],
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
                .WithOptimizationLevel(OptimizationLevel.Release)
                .WithNullableContextOptions(NullableContextOptions.Enable));

        using var fs = new FileStream(outputPath, FileMode.Create, FileAccess.Write, FileShare.Read);
        var result = compilation.Emit(fs);

        if (!result.Success)
        {
            var diags = result.Diagnostics
                .Where(d => d.Severity == DiagnosticSeverity.Error)
                .Select(d => d.ToString());
            throw new InvalidOperationException("Failed to compile OpenAPI classes assembly: " + string.Join(Environment.NewLine, diags));
        }
    }

    private static List<MetadataReference> GetTrustedPlatformAssemblyReferences()
    {
        var refs = new List<MetadataReference>();
        var tpa = AppContext.GetData("TRUSTED_PLATFORM_ASSEMBLIES") as string;
        if (string.IsNullOrWhiteSpace(tpa))
        {
            return refs;
        }

        var paths = tpa.Split(Path.PathSeparator, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        foreach (var p in paths)
        {
            // Some entries might not exist in constrained environments.
            if (File.Exists(p))
            {
                refs.Add(MetadataReference.CreateFromFile(p));
            }
        }

        return refs;
    }
}
